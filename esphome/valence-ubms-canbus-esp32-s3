esphome:
  name: valence-u-bms
  friendly_name: Valence U-BMS

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: !secret ws_key

ota:
  - platform: esphome
    password: !secret ws_ota_key

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: !secret ws_fb_ssid
    password: !secret ws_fb_password


# CAN Bus Configuration
canbus:
  - platform: esp32_can
    id: valence_can
    tx_pin: GPIO15
    rx_pin: GPIO16
    can_id: 1
    bit_rate: 500kbps
    
    on_frame:
      # 0xC0 - Main status message (SOC, mode, alarms, errors)
      - can_id: 0xC0
        then:
          - lambda: |-
              id(battery_soc).publish_state(x[0]);
              id(bms_mode).publish_state(x[1] & 0x3);
              id(voltage_alarms).publish_state(x[2]);
              id(internal_errors).publish_state(x[3]);
              id(current_alarms).publish_state(x[4]);
              id(modules_communicating).publish_state(x[5]);
              id(modules_balancing).publish_state(x[6]);
              id(shutdown_reason).publish_state(x[7]);
              
              // Decode mode to text
              const char* mode_str[] = {"Standby", "Charge", "Drive", "Unknown"};
              id(bms_mode_text).publish_state(mode_str[x[1] & 0x3]);
              
              // Decode charge stage (only in charge mode)
              if ((x[1] & 0x3) == 1) {
                uint8_t charge_stage = (x[1] >> 2) & 0x3;
                const char* stage_str[] = {"Main Charge", "Equalizing", "Floating", "N/A"};
                id(charge_stage_text).publish_state(stage_str[charge_stage]);
                
                // Inter-module balancing enabled
                bool inter_bal = (x[1] >> 4) & 0x1;
                id(inter_module_balancing).publish_state(inter_bal);
              }
              
              // Temperature warnings/alarms (byte 1 bits 5-7)
              id(low_temp_warning).publish_state((x[1] >> 5) & 0x1);
              id(low_temp_alarm).publish_state((x[1] >> 6) & 0x1);
              id(low_temp_shutdown).publish_state((x[1] >> 7) & 0x1);
              
              // Check for any errors or alarms
              bool has_errors = (x[2] != 0 || x[3] != 0 || x[4] != 0 || x[7] != 0);
              id(bms_error_flag).publish_state(has_errors);
              
              // Decode individual error flags from byte 2 (voltage_alarms)
              id(module_lost).publish_state(x[2] & 0x01);
              id(over_temp_warning).publish_state(x[2] & 0x02);
              id(over_temp_alarm).publish_state(x[2] & 0x04);
              id(low_capacity).publish_state(x[2] & 0x08);
              id(critically_discharged_alarm).publish_state(x[2] & 0x10);
              id(over_voltage_alarm).publish_state(x[2] & 0x20);
              id(over_temp_shutdown).publish_state(x[2] & 0x80);
              
              // Decode individual error flags from byte 3 (internal_errors)
              id(too_many_modules).publish_state(x[3] & 0x02);
              id(temp_sensor_failure).publish_state(x[3] & 0x04);
              id(voltage_sensor_failure).publish_state(x[3] & 0x08);
              id(current_sensor_failure).publish_state(x[3] & 0x10);
              id(soc_mismatch).publish_state(x[3] & 0x20);
              id(critically_discharged_warning).publish_state(x[3] & 0x40);
              id(over_voltage_warning).publish_state(x[3] & 0x80);
              
              // Decode individual error flags from byte 4 (current_alarms)
              id(over_current_warning).publish_state(x[4] & 0x01);
              id(over_current_alarm).publish_state(x[4] & 0x02);
              id(over_current_shutdown).publish_state(x[4] & 0x04);
              id(pcba_over_temp_warning).publish_state(x[4] & 0x08);
              id(pcba_over_temp_alarm).publish_state(x[4] & 0x10);
              id(pcba_over_temp_shutdown).publish_state(x[4] & 0x20);
              
              // Decode individual error flags from byte 7 (shutdown_reason)
              id(over_voltage_shutdown).publish_state(x[7] & 0x04);
              id(critically_discharged_shutdown).publish_state(x[7] & 0x08);
              id(vmu_timeout).publish_state(x[7] & 0x10);
              id(discharge_precharge_failure).publish_state(x[7] & 0x20);
              id(sanity_error).publish_state(x[7] & 0x40);
      
      # 0xC1 - Current and charge/discharge limits
      - can_id: 0xC1
        then:
          - lambda: |-
              // Battery voltage (byte 0)
              id(battery_voltage).publish_state(x[0]);
              
              // Current is signed 16-bit at bytes 1-2 (LSB first)
              int16_t current16 = (x[1] | (x[2] << 8));
              id(battery_current_16).publish_state(current16);
              
              // Current is signed byte at position 1
              int8_t current8 = (int8_t)x[1];
              id(battery_current_8).publish_state(current8);

              // Max discharge current (bytes 3-4, LSB first)
              uint16_t max_discharge = x[3] | (x[4] << 8);
              id(max_discharge_current).publish_state(max_discharge);
              
              // Max regenerative current (bytes 5 and 7, LSB first)
              uint16_t max_regen = x[5] | (x[7] << 8);
              id(max_regen_current).publish_state(max_regen);
              
              // Contactor states and requests (byte 6)
              id(contactor_opening_request).publish_state(x[6] & 0x1);
              id(discharge_contactor_state).publish_state((x[6] >> 1) & 0x1);
              
              // Insulation measurement state (bits 2-3)
              uint8_t insulation_state = (x[6] >> 2) & 0x3;
              const char* insul_str[] = {"Correct", "In Progress", "Fault", "Invalid"};
              id(insulation_state_text).publish_state(insul_str[insulation_state]);
              
              id(charge_contactor_state).publish_state((x[6] >> 4) & 0x1);
              id(charge_precharge_failure).publish_state((x[6] >> 5) & 0x1);
      
      # 0xC2 - Charge status
      - can_id: 0xC2
        then:
          - lambda: |-
              id(charge_current_setpoint).publish_state(x[0]);
              
              // Charge voltage setpoint (bytes 1-2, LSB first)
              uint16_t charge_voltage = x[1] | (x[2] << 8);
              id(charge_voltage_setpoint).publish_state(charge_voltage);
              
              // End of charge flag (byte 3, bit 2)
              bool charge_complete = (x[3] & 0x4) >> 2;
              id(charge_complete_flag).publish_state(charge_complete);
              
              // Inter balance request number (byte 4)
              id(inter_balance_request_num).publish_state(x[4]);
      
      # 0xC4 - Min/max cell voltages and temperatures
      - can_id: 0xC4
        then:
          - lambda: |-
              // Temperatures with -40°C offset
              id(max_cell_temp).publish_state(x[0] - 40);
              id(min_cell_temp).publish_state(x[1] - 40);
              id(max_pcb_temp).publish_state(x[3] - 40);
              
              // Cell voltages in mV (big endian - LSB first)
              float max_cell_v = ((x[4] | (x[5] << 8))) / 1000.0;
              float min_cell_v = ((x[6] | (x[7] << 8))) / 1000.0;
              id(max_cell_voltage).publish_state(max_cell_v);
              id(min_cell_voltage).publish_state(min_cell_v);
      
      # 0x180 - Hardware/Firmware revision
      - can_id: 0x180
        then:
          - lambda: |-
              char version[20];
              sprintf(version, "MC:%d.%d CR:%d.%d BL:%d.%d", 
                      x[0]/16, x[0]%16, x[1]/16, x[1]%16, x[2]/16, x[2]%16);
              id(firmware_version).publish_state(version);
              
              const char* type_str[] = {"LV", "HV", "Unknown", "SHV"};
              id(bms_type).publish_state(type_str[x[3]]);
              
              char hw_rev[10];
              sprintf(hw_rev, "%d.%d", x[4]/16, x[4]%16);
              id(hardware_revision).publish_state(hw_rev);
              
              char customer[4];
              customer[0] = x[5];
              customer[1] = x[6];
              customer[2] = x[7];
              customer[3] = '\0';
              id(customer_code).publish_state(customer);
      
      # 0x350 - Module 1 cells 1-3
      - can_id: 0x350
        then:
          - lambda: |-
              if (x.size() >= 8) {
                // Byte 0 = BMS#, Byte 1 = cell block group (0=1-3, 1=7-9)
                float c1 = ((x[2] << 8) | x[3]) / 1000.0;
                float c2 = ((x[4] << 8) | x[5]) / 1000.0;
                float c3 = ((x[6] << 8) | x[7]) / 1000.0;
                id(module1_cell1).publish_state(c1);
                id(module1_cell2).publish_state(c2);
                id(module1_cell3).publish_state(c3);
              }
      
      # 0x351 - Module 1 cell 4
      - can_id: 0x351
        then:
          - lambda: |-
              if (x.size() >= 4) {
                float c4 = ((x[2] << 8) | x[3]) / 1000.0;
                id(module1_cell4).publish_state(c4);
                
                // Calculate module voltage
                float module_v = id(module1_cell1).state + id(module1_cell2).state + 
                                 id(module1_cell3).state + id(module1_cell4).state;
                id(module1_voltage).publish_state(module_v);
              }
      
      # 0x56A - Module exists flags
      - can_id: 0x56A
        then:
          - lambda: |-
              if (x.size() >= 0) {
                // Count how many modules exist
                int module_count = 0;
                for (int i = 1; i < 8; i++) {
                  for (int bit = 0; bit < 8; bit++) {
                    if (x[i] & (1 << bit)) {
                      module_count++;
                    }
                  }
                }
                id(total_modules_present).publish_state(module_count);
              }
      
      # 0x66A - Insulation resistance
      - can_id: 0x66A
        then:
          - lambda: |-
              if (x.size() >= 4) {
                // 32-bit value in kOhm
                uint32_t resistance = (x[0] << 24) | (x[1] << 16) | (x[2] << 8) | x[3];
                id(insulation_resistance).publish_state(resistance);
              }
      
      # 0x66B - Insulation voltages
      - can_id: 0x66B
        then:
          - lambda: |-
              if (x.size() >= 0) {
                uint16_t v1 = (x[0] << 8) | x[1];
                uint16_t v2 = (x[2] << 8) | x[3];
                uint16_t v3 = (x[4] << 8) | x[5];
                uint16_t v4 = (x[6] << 8) | x[7];
                
                id(v_chassis_neg_first).publish_state(v1);
                id(v_pos_chassis_first).publish_state(v2);
                id(v_chassis_neg_next).publish_state(v3);
                id(v_pos_chassis_next).publish_state(v4);
              }
      
      # 0x06A - Module SOC (modules 1-7)
      - can_id: 0x06A
        then:
          - lambda: |-
              if (x.size() >= 0) {
                // Byte 0 = BMS#, bytes 1-7 = modules 1-7 SOC
                  id(module01_soc).publish_state(x[1] * 100  / 255.0);
                //id(module02_soc).publish_state(x[2] * 100 / 255.0); # module doesn't exist in 1s1p
                //id(module03_soc).publish_state(x[3] * 100 / 255.0); # module doesn't exist in 1s1p
                //id(module04_soc).publish_state(x[4] * 100 / 255.0); # module doesn't exist in 1s1p
                //id(module05_soc).publish_state(x[5] * 100 / 255.0); # module doesn't exist in 1s1p
                //id(module06_soc).publish_state(x[6] * 100 / 255.0); # module doesn't exist in 1s1p
                //id(module07_soc).publish_state(x[7] * 100 / 255.0); # module doesn't exist in 1s1p
              }
      # 0x06A - Module SOC (modules 8-15)
      - can_id: 0x06B # increments by letter for each 7 modules.
        then:
          - lambda: |-
              if (x.size() >= 8) {
                // Byte 0 = BMS#, bytes 1-7 = modules 1-7 SOC
                //id(module8_soc).publish_state(x[1] * 100  / 255.0);
                //id(module9_soc).publish_state(x[2] * 100 / 255.0); # module doesn't exist in 1s1p
                //id(module10_soc).publish_state(x[3] * 100 / 255.0); # module doesn't exist in 1s1p
                //id(module11_soc).publish_state(x[4] * 100 / 255.0); # module doesn't exist in 1s1p
                //id(module12_soc).publish_state(x[5] * 100 / 255.0); # module doesn't exist in 1s1p
                //id(module13_soc).publish_state(x[6] * 100 / 255.0); # module doesn't exist in 1s1p
                //id(module14_soc).publish_state(x[7] * 100 / 255.0); # module doesn't exist in 1s1p
              }
      
      # 0x16A - Module inter-balance flags
      - can_id: 0x16A
        then:
          - lambda: |-
              if (x.size() >= 0) {
                // Count modules currently balancing
                int balancing_count = 0;
                for (int i = 1; i < 8; i++) {
                  for (int bit = 0; bit < 8; bit++) {
                    if (x[i] & (1 << bit)) {
                      balancing_count++;
                    }
                  }
                }
                id(modules_inter_balancing).publish_state(balancing_count);
              }
      
      # 0x16C - Module sanity error flags
      - can_id: 0x16C
        then:
          - lambda: |-
              if (x.size() >= 0) {
                // Count modules with sanity errors
                int error_count = 0;
                for (int i = 1; i < 8; i++) {
                  for (int bit = 0; bit < 8; bit++) {
                    if (x[i] & (1 << bit)) {
                      error_count++;
                    }
                  }
                }
                id(modules_with_sanity_errors).publish_state(error_count);
              }

# Sensors
sensor:
  # Main battery metrics
  - platform: template
    id: battery_soc
    name: "Battery SOC"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    device_class: battery
    state_class: measurement
  
  - platform: template
    id: battery_voltage
    name: "Battery Voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: voltage
    state_class: measurement
  
  - platform: template
    id: battery_current_16 
    name: "Battery Current (16BIT)"
    unit_of_measurement: "A"
    accuracy_decimals: 0
    device_class: current
    state_class: measurement

  - platform: template
    id: battery_current_8
    name: "Battery Current (8BIT)"
    unit_of_measurement: "A"
    accuracy_decimals: 0
    device_class: current
    state_class: measurement

  - platform: template
    id: max_discharge_current
    name: "Max Discharge Current"
    unit_of_measurement: "A"
    accuracy_decimals: 0
    device_class: current
  
  - platform: template
    id: max_regen_current
    name: "Max Regen Current"
    unit_of_measurement: "A"
    accuracy_decimals: 0
    device_class: current
  
  # Charge parameters
  - platform: template
    id: charge_current_setpoint
    name: "Charge Current Setpoint"
    unit_of_measurement: "A"
    accuracy_decimals: 0
    device_class: current
  
  - platform: template
    id: charge_voltage_setpoint
    name: "Charge Voltage Setpoint"
    unit_of_measurement: "V"
    accuracy_decimals: 0
    device_class: voltage
  
  - platform: template
    id: inter_balance_request_num
    name: "Inter Balance Request Number"
    accuracy_decimals: 0
  
  # Temperature sensors
  - platform: template
    id: max_cell_temp
    name: "Max Cell Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 0
    device_class: temperature
    state_class: measurement
  
  - platform: template
    id: min_cell_temp
    name: "Min Cell Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 0
    device_class: temperature
    state_class: measurement
  
  - platform: template
    id: max_pcb_temp
    name: "Max PCB Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 0
    device_class: temperature
    state_class: measurement
  
  # Cell voltage sensors
  - platform: template
    id: max_cell_voltage
    name: "Max Cell Voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: voltage
    state_class: measurement
  
  - platform: template
    id: min_cell_voltage
    name: "Min Cell Voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: voltage
    state_class: measurement
  
  # Module 1 individual cell voltages
  - platform: template
    id: module1_cell1
    name: "Module 1 Cell 1"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: voltage
    internal: true
  
  - platform: template
    id: module1_cell2
    name: "Module 1 Cell 2"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: voltage
    internal: true
  
  - platform: template
    id: module1_cell3
    name: "Module 1 Cell 3"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: voltage
    internal: true
  
  - platform: template
    id: module1_cell4
    name: "Module 1 Cell 4"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: voltage
    internal: true
  
  - platform: template
    id: module1_voltage
    name: "Module 1 Total Voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: voltage
    state_class: measurement
  
  # Module SOC sensors
  - platform: template
    id: module01_soc
    name: "Module 1 SOC"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    device_class: battery
    state_class: measurement
  
  # Status counters
  - platform: template
    id: modules_communicating
    name: "Modules Communicating"
    accuracy_decimals: 0
    state_class: measurement
  
  - platform: template
    id: modules_balancing
    name: "Modules Balancing"
    accuracy_decimals: 0
    state_class: measurement
  
  - platform: template
    id: total_modules_present
    name: "Total Modules Present"
    accuracy_decimals: 0
    state_class: measurement
  
  - platform: template
    id: modules_inter_balancing
    name: "Modules Inter-Balancing"
    accuracy_decimals: 0
    state_class: measurement
  
  - platform: template
    id: modules_with_sanity_errors
    name: "Modules with Sanity Errors"
    accuracy_decimals: 0
    state_class: measurement
  
  # Insulation monitoring
  - platform: template
    id: insulation_resistance
    name: "Insulation Resistance"
    unit_of_measurement: "kΩ"
    accuracy_decimals: 0
    state_class: measurement
  
  - platform: template
    id: v_chassis_neg_first
    name: "V Chassis-Neg First"
    unit_of_measurement: "V"
    accuracy_decimals: 0
    device_class: voltage
  
  - platform: template
    id: v_pos_chassis_first
    name: "V Pos-Chassis First"
    unit_of_measurement: "V"
    accuracy_decimals: 0
    device_class: voltage
  
  - platform: template
    id: v_chassis_neg_next
    name: "V Chassis-Neg Next"
    unit_of_measurement: "V"
    accuracy_decimals: 0
    device_class: voltage
  
  - platform: template
    id: v_pos_chassis_next
    name: "V Pos-Chassis Next"
    unit_of_measurement: "V"
    accuracy_decimals: 0
    device_class: voltage
  
  # Alarm/error codes (numeric)
  - platform: template
    id: voltage_alarms
    name: "Voltage Alarms Code"
    accuracy_decimals: 0
    internal: true
  
  - platform: template
    id: internal_errors
    name: "Internal Errors Code"
    accuracy_decimals: 0
    internal: true
  
  - platform: template
    id: current_alarms
    name: "Current Alarms Code"
    accuracy_decimals: 0
    internal: true
  
  - platform: template
    id: shutdown_reason
    name: "Shutdown Reason Code"
    accuracy_decimals: 0
    internal: true
  
  - platform: template
    id: bms_mode
    name: "BMS Mode Code"
    accuracy_decimals: 0
    internal: true

# Binary sensors (flags)
binary_sensor:
  # General status
  - platform: template
    id: bms_error_flag
    name: "BMS Has Errors"
    device_class: problem
  
  - platform: template
    id: charge_complete_flag
    name: "Charge Complete"
    device_class: battery_charging
  
  - platform: template
    id: inter_module_balancing
    name: "Inter-Module Balancing"
  
  - platform: template
    id: low_temp_warning
    name: "Low Temperature Warning"
    device_class: cold
  
  - platform: template
    id: low_temp_alarm
    name: "Low Temperature Alarm"
    device_class: problem
  
  - platform: template
    id: low_temp_shutdown
    name: "Low Temperature Shutdown"
    device_class: problem
  
  - platform: template
    id: contactor_opening_request
    name: "Contactor Opening Request"
  
  - platform: template
    id: discharge_contactor_state
    name: "Discharge Contactor Closed"
    device_class: power
  
  - platform: template
    id: charge_contactor_state
    name: "Charge Contactor Closed"
    device_class: power
  
  - platform: template
    id: charge_precharge_failure
    name: "Charge Precharge Failure"
    device_class: problem
  
  # Voltage and Temperature Alarms (byte 2)
  - platform: template
    id: module_lost
    name: "Module Communication Lost"
    device_class: problem
  
  - platform: template
    id: over_temp_warning
    name: "Over Temperature Warning"
    device_class: heat
  
  - platform: template
    id: over_temp_alarm
    name: "Over Temperature Alarm"
    device_class: problem
  
  - platform: template
    id: low_capacity
    name: "Low Battery Capacity"
    device_class: battery
  
  - platform: template
    id: critically_discharged_alarm
    name: "Critically Discharged Alarm"
    device_class: problem
  
  - platform: template
    id: over_voltage_alarm
    name: "Over Voltage Alarm"
    device_class: problem
  
  - platform: template
    id: over_temp_shutdown
    name: "Over Temperature Shutdown"
    device_class: problem
  
  # Internal Errors (byte 3)
  - platform: template
    id: too_many_modules
    name: "Too Many Modules"
    device_class: problem
  
  - platform: template
    id: temp_sensor_failure
    name: "Temperature Sensor Failure"
    device_class: problem
  
  - platform: template
    id: voltage_sensor_failure
    name: "Voltage Sensor Failure"
    device_class: problem
  
  - platform: template
    id: current_sensor_failure
    name: "Current Sensor Failure"
    device_class: problem
  
  - platform: template
    id: soc_mismatch
    name: "SOC Mismatch Between Modules"
    device_class: problem
  
  - platform: template
    id: critically_discharged_warning
    name: "Critically Discharged Warning"
    device_class: battery
  
  - platform: template
    id: over_voltage_warning
    name: "Over Voltage Warning"
    device_class: problem
  
  # Current and PCB Alarms (byte 4)
  - platform: template
    id: over_current_warning
    name: "Over Current Warning"
    device_class: problem
  
  - platform: template
    id: over_current_alarm
    name: "Over Current Alarm"
    device_class: problem
  
  - platform: template
    id: over_current_shutdown
    name: "Over Current Shutdown"
    device_class: problem
  
  - platform: template
    id: pcba_over_temp_warning
    name: "PCB Over Temperature Warning"
    device_class: heat
  
  - platform: template
    id: pcba_over_temp_alarm
    name: "PCB Over Temperature Alarm"
    device_class: problem
  
  - platform: template
    id: pcba_over_temp_shutdown
    name: "PCB Over Temperature Shutdown"
    device_class: problem
  
  # Shutdown Reasons (byte 7)
  - platform: template
    id: over_voltage_shutdown
    name: "Over Voltage Shutdown"
    device_class: problem
  
  - platform: template
    id: critically_discharged_shutdown
    name: "Critically Discharged Shutdown"
    device_class: problem
  
  - platform: template
    id: vmu_timeout
    name: "VMU Communication Timeout"
    device_class: problem
  
  - platform: template
    id: discharge_precharge_failure
    name: "Discharge Pre-charge Failure"
    device_class: problem
  
  - platform: template
    id: sanity_error
    name: "Sanity Error"
    device_class: problem

# Text sensors
text_sensor:
  - platform: template
    id: bms_mode_text
    name: "BMS Mode"
  
  - platform: template
    id: charge_stage_text
    name: "Charge Stage"
  
  - platform: template
    id: insulation_state_text
    name: "Insulation State"
  
  - platform: template
    id: firmware_version
    name: "Firmware Version"
  
  - platform: template
    id: hardware_revision
    name: "Hardware Revision"
  
  - platform: template
    id: bms_type
    name: "BMS Type"
  
  - platform: template
    id: customer_code
    name: "Customer Code"
  
  # Detailed error reporting with decoded messages
  - platform: template
    id: error_details
    name: "BMS Error Details"
    lambda: |-
      // Check if we have valid data
      if (!id(voltage_alarms).has_state() || 
          !id(internal_errors).has_state() || 
          !id(current_alarms).has_state() || 
          !id(shutdown_reason).has_state() ||
          id(voltage_alarms).state > 255 ||
          id(internal_errors).state > 255 ||
          id(current_alarms).state > 255 ||
          id(shutdown_reason).state > 255) {
        return {"Waiting for CAN data..."};
      }
      
      std::string errors = "";
      uint8_t volt_alarms = (uint8_t)id(voltage_alarms).state;
      uint8_t int_errors = (uint8_t)id(internal_errors).state;
      uint8_t curr_alarms = (uint8_t)id(current_alarms).state;
      uint8_t shutdown = (uint8_t)id(shutdown_reason).state;
      
      // Decode byte 2 (voltage_alarms) - voltage and temperature issues
      if (volt_alarms & 0x01) errors += "Module Lost; ";
      if (volt_alarms & 0x02) errors += "Over Temp Warning; ";
      if (volt_alarms & 0x04) errors += "Over Temp Alarm; ";
      if (volt_alarms & 0x08) errors += "Low Capacity; ";
      if (volt_alarms & 0x10) errors += "Critically Discharged Alarm; ";
      if (volt_alarms & 0x20) errors += "Over Voltage Alarm; ";
      if (volt_alarms & 0x80) errors += "Over Temp Shutdown; ";
      
      // Decode byte 3 (internal_errors) - sensor and system issues
      if (int_errors & 0x02) errors += "Too Many Modules; ";
      if (int_errors & 0x04) errors += "Temp Sensor Failure; ";
      if (int_errors & 0x08) errors += "Volt Sensor Failure; ";
      if (int_errors & 0x10) errors += "Current Sensor Failure; ";
      if (int_errors & 0x20) errors += "SOC Mismatch; ";
      if (int_errors & 0x40) errors += "Critically Discharged Warning; ";
      if (int_errors & 0x80) errors += "Over Volt Warning; ";
      
      // Decode byte 4 (current_alarms) - current and PCB issues
      if (curr_alarms & 0x01) errors += "Over Current Warning; ";
      if (curr_alarms & 0x02) errors += "Over Current Alarm; ";
      if (curr_alarms & 0x04) errors += "Over Current Shutdown; ";
      if (curr_alarms & 0x08) errors += "PCBA Over Temp Warning; ";
      if (curr_alarms & 0x10) errors += "PCBA Over Temp Alarm; ";
      if (curr_alarms & 0x20) errors += "PCBA Over Temp Shutdown; ";
      
      // Decode byte 7 (shutdown_reason) - critical shutdowns
      if (shutdown & 0x04) errors += "Over Volt Shutdown; ";
      if (shutdown & 0x08) errors += "Critically Discharged Shutdown; ";
      if (shutdown & 0x10) errors += "VMU Timeout; ";
      if (shutdown & 0x20) errors += "Discharge Pre-charge Failure; ";
      if (shutdown & 0x40) errors += "Sanity Error; ";
      
      if (errors.empty()) {
        return {"No errors"};
      }
      // Remove trailing semicolon and space
      if (errors.length() > 2) {
        errors = errors.substr(0, errors.length() - 2);
      }
      return {errors};
    update_interval: 5s
